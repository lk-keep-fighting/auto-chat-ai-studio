# wait_for_response 流程说明

## 核心逻辑

`wait_for_response()` 方法通过检测Run按钮状态来判断AI是否完成响应。

## 判断标准

### is_ai_running() 方法

```python
def is_ai_running(self):
    """检查 AI 是否正在运行（通过按钮状态判断）"""
    # 查找 Run 按钮
    run_button = self.page.locator('button[aria-label="Run"]').first
    button_html = run_button.inner_html()
    
    # 如果按钮显示 "Stop"，说明 AI 正在运行
    if 'Stop' in button_html:
        return True
    
    # 如果按钮显示 "Run"，说明 AI 已完成
    if 'Run' in button_html:
        return False
```

**判断依据**：
- ✅ AI运行中：按钮显示 "Stop" → 返回 `True`
- ✅ AI已完成：按钮显示 "Run" → 返回 `False`

## 等待流程

### 1. 无限循环等待

```python
while True:  # 无限循环，直到AI完成
    if self.is_ai_running():
        # AI 正在运行，继续等待
        logger.info(f"⏳ AI 正在处理... (已等待 {elapsed} 秒)")
        time.sleep(2)
        continue
    else:
        # AI 已完成
        logger.info("✅ AI 处理完成，等待响应稳定...")
        break
```

**特点**：
- ✅ 使用 `while True` 无限循环
- ✅ 只有当 `is_ai_running()` 返回 `False` 时才 `break`
- ✅ 确保一直等到Run按钮可用

### 2. 超时处理

```python
if elapsed > timeout:
    timeout_count += 1
    
    # 如果超过3次超时，询问用户
    if timeout_count >= 3:
        user_input = input("👉 请输入操作（Enter继续等待）: ")
        
        if not user_input:
            # 继续等待
            start_time = time.time()  # 重置计时器
            timeout_count = 0
    else:
        # 自动继续等待
        logger.info("💡 继续等待 AI 完成...")
        start_time = time.time()
```

**特点**：
- ✅ 前2次超时自动继续
- ✅ 第3次超时询问用户
- ✅ 用户可以选择继续等待、跳过或退出
- ✅ 重置计时器后继续等待

### 3. 响应稳定等待

```python
else:
    # AI 已完成，等待响应稳定
    logger.info("✅ AI 处理完成，等待响应稳定...")
    
    # 步骤25需要更长时间渲染表格
    if step_number == 25:
        logger.info("📊 步骤25：等待表格渲染（5秒）...")
        time.sleep(5)
    else:
        time.sleep(3)
    break
```

**特点**：
- ✅ Run按钮可用后，等待响应稳定
- ✅ 步骤25等待5秒（表格渲染）
- ✅ 其他步骤等待3秒

## 完整时间线

### 步骤25的完整等待流程

```
1. 发送提示词
   ↓
2. AI开始生成（Run按钮变为Stop）
   ↓
3. wait_for_response() 循环检测
   - 每2秒检查一次按钮状态
   - 每10秒输出一次等待日志
   ↓
4. AI生成完成（Stop按钮变为Run）
   - is_ai_running() 返回 False
   ↓
5. 等待响应稳定（5秒）
   - 让表格有时间渲染
   ↓
6. extract_response() 提取数据
   - 检查响应是否为空（0-3秒）
   - 等待表格元素出现（0-10秒）
   - 从DOM提取表格数据
   ↓
7. 保存数据
```

### 总等待时间

- **AI生成时间**：变化（通常10-120秒）
- **响应稳定**：5秒（步骤25）或 3秒（其他步骤）
- **检查响应**：0-3秒（如果为空）
- **等待表格**：0-10秒（如果未出现）
- **总计**：AI生成时间 + 5-18秒

## 日志示例

### 正常流程

```
⏳ 等待 AI 响应步骤 25...
⏳ AI 正在处理... (已等待 10 秒)
⏳ AI 正在处理... (已等待 20 秒)
⏳ AI 正在处理... (已等待 30 秒)
✅ AI 处理完成，等待响应稳定...
📊 步骤25：等待表格渲染（5秒）...
✅ AI 响应完成（总等待时间: 35 秒）
```

### 超时流程

```
⏳ 等待 AI 响应步骤 25...
⏳ AI 正在处理... (已等待 10 秒)
⏳ AI 正在处理... (已等待 20 秒)
...
⏳ AI 正在处理... (已等待 60 秒)
⚠️ 等待超时（第 1 次），但 AI 仍在运行
💡 继续等待 AI 完成... (将在第 3 次超时后询问)
⏳ AI 正在处理... (已等待 10 秒)
...
⏳ AI 正在处理... (已等待 60 秒)
⚠️ 等待超时（第 2 次），但 AI 仍在运行
💡 继续等待 AI 完成... (将在第 3 次超时后询问)
⏳ AI 正在处理... (已等待 10 秒)
...
⏳ AI 正在处理... (已等待 60 秒)
⚠️ 等待超时（第 3 次），但 AI 仍在运行
⚠️ 已超时 3 次（180 秒）
============================================================
⚠️ AI 仍在处理步骤 25，已等待 180 秒
============================================================
可选操作:
  1. 直接按 Enter - 继续等待
  2. 输入 'skip' - 跳过当前步骤（不推荐）
  3. 输入 'quit' - 退出程序

👉 请输入操作（Enter继续等待）: [用户按Enter]
✅ 继续等待 AI 完成...
⏳ AI 正在处理... (已等待 10 秒)
...
✅ AI 处理完成，等待响应稳定...
```

## 关键特性

### 1. 可靠性

- ✅ 基于按钮状态判断，不依赖时间
- ✅ 无限循环，确保等到AI完成
- ✅ 不会因为超时而跳过步骤

### 2. 容错性

- ✅ 超时后自动重试（前2次）
- ✅ 第3次超时询问用户
- ✅ 用户可以选择继续等待

### 3. 灵活性

- ✅ 支持不同步骤的不同等待时间
- ✅ 步骤25特殊处理（表格渲染）
- ✅ 支持手动干预

### 4. 可观察性

- ✅ 每10秒输出等待状态
- ✅ 显示已等待时间
- ✅ 显示超时次数
- ✅ 详细的日志输出

## 常见问题

### Q1: 为什么不直接等待固定时间？

**回答**：
- 不同的提示词，AI生成时间差异很大
- 固定时间可能太短（导致跳过）或太长（浪费时间）
- 基于按钮状态更可靠

### Q2: 为什么需要"响应稳定"等待？

**回答**：
- Run按钮可用时，响应可能还在渲染
- 特别是表格，需要时间渲染DOM
- 等待几秒确保内容完全加载

### Q3: 为什么步骤25等待5秒？

**回答**：
- 步骤25输出的是表格
- 表格渲染比文本慢
- 5秒是经验值，可以根据实际情况调整

### Q4: 如果表格渲染超过5秒怎么办？

**回答**：
- `extract_response()` 会主动等待表格元素（最多10秒）
- 总共有 5 + 10 = 15秒 的等待时间
- 如果还不够，可以增加等待时间

## 优化建议

### 1. 动态调整等待时间

根据历史数据动态调整等待时间：

```python
# 记录每个步骤的平均生成时间
step_avg_time = {
    1: 30,
    2: 20,
    ...
    25: 60
}

# 使用历史数据设置超时
timeout = step_avg_time.get(step_number, 60) * 1.5
```

### 2. 更精确的表格检测

不仅等待表格元素，还检查表格是否有数据：

```python
# 等待表格有至少1行数据
table = last_response_element.locator('table').first
rows = table.locator('tr').count()
while rows < 2:  # 表头 + 至少1行数据
    time.sleep(1)
    rows = table.locator('tr').count()
```

### 3. 进度指示

显示更详细的进度信息：

```python
# 显示进度条
progress = elapsed / expected_time * 100
logger.info(f"⏳ AI 正在处理... {progress:.0f}% (已等待 {elapsed} 秒)")
```

## 总结

`wait_for_response()` 方法通过检测Run按钮状态，确保一直等到AI完成响应。关键特性：

1. ✅ 无限循环，基于按钮状态判断
2. ✅ 超时后自动重试，不跳过步骤
3. ✅ 步骤25特殊处理，等待表格渲染
4. ✅ 详细的日志输出，便于监控

这个设计确保了每个步骤都能完整执行，不会因为超时而跳过，同时也给用户提供了手动干预的机会。
